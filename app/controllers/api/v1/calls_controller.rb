class Api::V1::CallsController < ProtectedController
  before_action :authorize_user
  EVENT_INCOMING = "incoming"
  EVENT_ACCEPT = "accept"
  EVENT_END = "end"
  EVENT_CANCEL = "cancel"
  EVENT_REJECT = "reject"
  # =begin
  # @apiVersion 1.0.0
  # @api {post} /api/v1/calls System event message for call
  # @apiDescription System event message for call
  # @apiName SystemEventMessageForCall
  # @apiGroup Calls
  #
  # @apiParam {String} access_token User access token
  # @apiParam {String} user_email It's using qiscus_email
  # @apiParam {String} user_type User_type = 'caller' or 'callee'
  # @apiParam {String} call_room_id It's generated by client
  # @apiParam {Boolean} is_video Is_video = 'true' or 'false'
  # @apiParam {String} call_event Call_event = 'incoming', 'accept', 'end', 'cancel', 'reject'. incoming and cancel send from caller user. accept, reject send from callee user. end can be send from caller and callee user.
  # @apiParam {String} [extras = null] Extras must be json object string
  # @apiParam {String} [bot_user_email = null] If this parameter set, it will create a group chat with is_official_chat = true
  # =end
  def create
    begin
      user_email = params[:user_email]
      if user_email.nil? || user_email == ""
        raise InputError.new("user_email cannot be empty.")
      end

      user1 = User.find_by(qiscus_email: user_email, application_id: @current_user.application.id)
      if user1.nil?
        raise InputError.new("User is not found.")
      end

      user_type = params[:user_type]
      if user_type.nil? || !user_type.present? || user_type == ""
        raise InputError.new("user_type can't be empty.")
      else
        if user_type.downcase.delete(' ') != "caller" && user_type.downcase.delete(' ') != "callee"
          raise InputError.new("Permitted user_type is 'caller' or 'callee'.")
        end
      end

      call_room_id = params[:call_room_id]
      if call_room_id.nil? || call_room_id == ""
        raise InputError.new("call_room_id cannot be empty.")
      end

      if params[:is_video].nil? || !params[:is_video].present? || params[:is_video] == ""
        raise InputError.new("is_video can't be empty.")
      else
        if params[:is_video].downcase.delete(' ') != "true" && params[:is_video].downcase.delete(' ') != "false"
          raise InputError.new("Permitted is_video is 'true' or 'false'.")
        end
      end

      if params[:is_video] == "true"
        is_video = true
      else
        is_video = false
      end

      call_event = params[:call_event]
      if call_event.nil? || !call_event.present? || call_event == ""
        raise InputError.new("Call event can't be empty.")
      else
        if call_event.downcase.delete(' ') != "incoming" && call_event.downcase.delete(' ') != "accept" && call_event.downcase.delete(' ') != "end" && call_event.downcase.delete(' ') != "cancel" && call_event.downcase.delete(' ') != "reject"
          raise InputError.new("Permitted call_event is 'incoming', 'accept', 'end', 'cancel', 'reject'.")
        end
      end



      user2 = @current_user
      # define caller and callee user
      if user_type == 'callee'
        caller_user = user2
        callee_user = user1
      else
        caller_user = user1
        callee_user = user2
      end

      qiscus_sdk = QiscusSdk.new(@current_user.application.app_id, @current_user.application.qiscus_sdk_secret)
      bot_user_email = params[:bot_user_email]

      if bot_user_email.nil?
        # Looking for a single chat between caller and callee
        chat_room = ChatRoom.where(is_group_chat: false, user_id: [caller_user.id, callee_user.id], target_user_id: [caller_user.id, callee_user.id]).first

        if chat_room.nil?
          # If single chat is nil then create single chat between caller and callee
          emails = [caller_user.qiscus_email, callee_user.qiscus_email]
          room = qiscus_sdk.get_or_create_room_with_target_rest(emails) # call sdk to create single room

          # Then get room_id from sdk
          qiscus_room_id = room.id

          # Insert data into qisme database
          chat_room = ChatRoom.find_by(qiscus_room_id: qiscus_room_id, application_id: @current_user.application.id)

          # if chat room with room id and room topic id not exist then create it
          if chat_room.nil?
            chat_name = "Group Chat Name"

            chat_room = ChatRoom.new(
              group_chat_name: chat_name,
              qiscus_room_name: chat_name,
              qiscus_room_id: qiscus_room_id,
              is_group_chat: false,
              user_id: @current_user.id,
              target_user_id: callee_user.id,
              application_id: @current_user.application.id
            )

            chat_room.save!

            ChatUser.create(chat_room_id: chat_room.id, user_id: @current_user.id) unless ChatUser.exists?(chat_room_id: chat_room.id, user_id: @current_user.id)
            ChatUser.create(chat_room_id: chat_room.id, user_id: callee_user.id) unless ChatUser.exists?(chat_room_id: chat_room.id, user_id: callee_user.id)
          end
        else
          # If single chat already exist then get qiscus_room_id
          qiscus_room_id = chat_room.qiscus_room_id
        end
      else
        bot_user = User.find_by(qiscus_email: bot_user_email, application_id: @current_user.application_id)
        if bot_user.nil?
          raise InputError.new("Bot user is not found.")
        end

        # Looking for a group chat with is_official_chat=true
        # The participants are caller, callee and bot
        chat_room = ChatRoom.where(is_group_chat: true, is_official_chat: true, user_id: [caller_user.id, callee_user.id], target_user_id: [caller_user.id, callee_user.id]).first

        if chat_room.nil?
          # If group chat is nil then create group chat with caller, callee, and bot as participants
          chat_name = "Group Chat Name"
          participants = [caller_user.qiscus_email, callee_user.qiscus_email, bot_user.qiscus_email]
          room = qiscus_sdk.create_room(chat_name, participants, @current_user.qiscus_email) # call sdk to create group chat

          # Then get room_id from sdk
          qiscus_room_id = room.id

          # Insert data into qisme database
          chat_room = ChatRoom.find_by(qiscus_room_id: qiscus_room_id, application_id: @current_user.application.id)

          # if chat room with room id and room topic id not exist then create it
          if chat_room.nil?
            chat_room = ChatRoom.new(
              group_chat_name: chat_name,
              qiscus_room_name: chat_name,
              qiscus_room_id: qiscus_room_id,
              is_group_chat: true,
              user_id: @current_user.id,
              target_user_id: callee_user.id,
              application_id: @current_user.application.id,
              is_official_chat: true
            )

            chat_room.save!

            ChatUser.create(chat_room_id: chat_room.id, user_id: @current_user.id) unless ChatUser.exists?(chat_room_id: chat_room.id, user_id: @current_user.id)
            ChatUser.create(chat_room_id: chat_room.id, user_id: callee_user.id) unless ChatUser.exists?(chat_room_id: chat_room.id, user_id: callee_user.id)
            ChatUser.create(chat_room_id: chat_room.id, user_id: bot_user.id) unless ChatUser.exists?(chat_room_id: chat_room.id, user_id: bot_user.id)
          end
        else
          # If single chat already exist then get qiscus_room_id
          qiscus_room_id = chat_room.qiscus_room_id
        end
      end


      # Define system_event_type to be stored in payload
      system_event_type = "call"
      
      # define message because its has 5 call_event ('incoming', 'accept', 'end', 'cancel', 'reject')
      if call_event == EVENT_INCOMING
        message = "#{caller_user.fullname} call #{callee_user.fullname}"
      elsif call_event == EVENT_ACCEPT
        message = "#{callee_user.fullname} accept call from #{caller_user.fullname}"
      elsif call_event == EVENT_END
        message = "#{user2.fullname} end call to #{user1.fullname}"
      elsif call_event == EVENT_CANCEL
        message = "#{caller_user.fullname} cancel call to #{callee_user.fullname}"
      elsif call_event == EVENT_REJECT
        message = "#{callee_user.fullname} reject call from #{caller_user.fullname}"
      end

      # send data to call_logs
      CallLog.create(caller_user_id: caller_user.id, callee_user_id: callee_user.id, call_event: call_event, message: message, application_id: @current_user.application_id, call_room_id: call_room_id)

      # Create payload
      payload = {
        "system_event_type":  system_event_type,
        "caller_user":        caller_user,
        "callee_user":        callee_user,
        "message":            message,
        "call_room_id":       call_room_id,
        "is_video":           is_video,
        "call_event":         call_event
      }

      extras = params[:extras] # string

      # set payload for extras parameter
      if !extras.nil?
        qiscus_ios_pn = JSON.parse(extras)['qiscus_ios_pn']
        if !qiscus_ios_pn.nil?
          extras = JSON.parse(extras)
          extras['qiscus_ios_pn']['payload'] = payload
          extras = extras.to_json
        end

      end

      # Set android payload
       android_payload = {
         data: payload
       }

      # Set ios payload
      ios_payload = {
        "system_event_type":  system_event_type,
        "caller_user":        caller_user.as_json.to_json,
        "callee_user":        callee_user.as_json.to_json,
        "message":            message,
        "call_room_id":       call_room_id,
        "is_video":           is_video,
        "call_event":         call_event
      }

      # Alert for ios PN
      alert = {
          title: "Incoming Call",
          body: "#{caller_user.fullname} calling you"
      }
      sound = "phone_ring.caf"

      type = "custom"
      qiscus_token = @current_user.qiscus_token
      topic_id = qiscus_room_id
      posted_event = [EVENT_INCOMING,EVENT_CANCEL,EVENT_REJECT]
      # post system event message for incoming,cancel and reject call_event
      if posted_event.include? call_event
        qiscus_sdk.post_system_event_message(type, topic_id, "", [], "", payload.to_json, message, extras)
      end

      # send call push notification
      userdevicetokens = user1.user_device_tokens

      # find fcm_key that store in applications table
			fcm_key = @current_user.application.fcm_key

      registration_ids = Array.new

      userdevicetokens.each do | u |
        # collect android devicetoken into array
        if u.user_type == "android"
          registration_ids.push(u.devicetoken)
        end

        # send push notification to ios for call signaling
        if @current_user.application.is_send_call_pn == true
          if u.user_type == 'ios'
            SendApnsJob.perform_later(@current_user.application, alert, u.devicetoken, ios_payload, sound)
          end
        end
      end

      # send push notification to android using fcm
      FcmClient.send(fcm_key, registration_ids, android_payload)

      render json: {
        data: payload
      }
    rescue ActiveRecord::RecordInvalid => e
      msg = ""
      e.record.errors.map do |k, v|
        key = k.to_s.humanize
        msg = msg + "#{key} #{v}, "
      end

      msg = msg.chomp(", ") + "."
      render json: {
        error: {
          message: msg,
          backtrace: e.backtrace
        }
      }, status: 422 and return

    rescue => e
      render json: {
        error: {
          message: e.message,
          class: e.class.name
        }
      }, status: 422 and return
    end
  end

  # =begin
  # @apiVersion 1.0.0
  # @api {get} /api/v1/calls List of user call logs
  # @apiDescription CallLogs
  # @apiName CallLogs
  # @apiGroup Calls
  #
  # @apiParam {String} access_token User access token
  # @apiParam {Number} page Page number
	# @apiParam {Number} limit Limit
	# @apiParam {String} [start_date] Filter call logs by date. filter this by start_date and end_date. use format YYYY-MM-DD
	# @apiParam {String} [end_date] Filter call logs by date. filter this by start_date and end_date. use format YYYY-MM-DD
  # =end
  def index
    total_page = 0
    total = 0
    limit = params[:limit]
    page = params[:page]

    user = @current_user
    call_logs = CallLog.where(caller_user_id: user.id, application_id: user.application_id)
		call_logs = call_logs.or(CallLog.where(callee_user_id: user.id, application_id: user.application_id))

		if params[:start_date].present? && params[:end_date].present?
			start_date = params[:start_date].to_time
			end_date = params[:end_date].to_time

			call_logs = call_logs.where(created_at: start_date.beginning_of_day..end_date.end_of_day)
    end

    # update call duration and connected_at from call sdk
    call_logs.each do |call_log|
      if call_log.status == "missed"  # this assume that "missed" status is because the user call is on going
        call_sdk = QiscusCallSdk.new()
        connected_at, duration, status = call_sdk.logs_by_call_room_id(call_log.call_room_id)

        call_log.update(duration: duration, connected_at: connected_at, status: status)
      end
    end

    call_logs = call_logs.order(created_at: :desc)

    total = call_logs.count

    # pagination only when exist
    if page.present?
      call_logs = call_logs.page(page)
    end

    # if limit and page present, then use kaminari pagination
    if limit.present? && page.present?
      call_logs = call_logs.per(limit)
    # else use limit from ActiveRecord
    elsif limit.present?
      call_logs = call_logs.limit(limit)
    else
      limit = 25
      call_logs = call_logs.limit(25)
    end

    total_page = (total / limit.to_f).ceil

    render json: {
      meta: {
        limit: limit.to_i,
        page: page == nil || page.to_i < 0 ? 0 : page.to_i,
        total_page: total_page,
        total: total,
      },
      data: call_logs
    }
    rescue ActiveRecord::RecordInvalid => e
      msg = ""
      e.record.errors.map do |k, v|
        key = k.to_s.humanize
        msg = msg + "#{key} #{v}, "
      end

      msg = msg.chomp(", ") + "."
      render json: {
        error: {
          message: msg,
          backtrace: e.backtrace
        }
      }, status: 422 and return

    rescue => e
      render json: {
        error: {
          message: e.message,
          class: e.class.name
        }
      }, status: 422 and return

  end
end
